# 쿠키(cookie)와 세션(session)


#### HTTP의 특징과 쿠키와 세션을 사용하는 이유

HTTP 프로토콜 환경에서 서버는 클라이언트가 누구인지 확인해야합니다. 그 이유는 HTTP 프로토콜이 connectionless, stateless한 특성이 있기 때문입니다.

| **connectionless(비연결성)**                                 |
| ------------------------------------------------------------ |
| 클라이언트가 요청을 한 후 응답을 받으면 그 연결을 끊어 버리는 특징  HTTP는 먼저 클라이언트가 request를 서버에 보내면, 서버는 클라이언트에게 요청에 맞는 response를 보내고 접속을 끊는 특성이 있다. 헤더에 `keep-alive`라는 값을 줘서 커넥션을 재활용하는데 HTTP1.1에서는 이것이 디폴트다. 그럼 keep-alive 옵션을 사용하면 될 것 같..지만  keep-alive는 **오히려 성능 하락의 주범인 경우가 많다**. 사용자가 많다면 연결이 늘어나서 새로운 사용자를 받아들이지 못하는 경우가 빈번히 일어나므로 사용자가 많고 유동이 많은 서비스에서는 사용이 권장되지 않는다. |

| **stateless(비상태성)**                                      |
| ------------------------------------------------------------ |
| 통신이 끝나면 상태를 유지하지 않는 특징  연결을 끊는 순간 클라이언트와 서버의 통신이 끝나며 상태 정보는 유지하지 않는 특성 |

이는 서버의 자원을 절약하기 위해 모든 사용자의 요청마다 연결과 해제의 과정을 거치기 때문에 연결 상태가 유지되지 않고, 연결 해제 후에 상태 정보가 저장되지 않는다는 것 입니다.

하지만, 이로 인해 사용자를 식별할 수 없어서 같은 사용자가 요청을 여러번 하더라도 매번 새로운 사용자로 인식하는 단점이 있습니다.

하지만 우리가 사용하고 있는 웹사이트를 생각해보면 로그인을 한 번 하고나면 그 사이트에서는 다시 로그인할 필요 없이

여러 페이지의 기능들을 이용할 수 있고 심지어 브라우저를 종료했다가 나중에 다시 접속했을 때도 그 로그인 상태를 유지할 수도 있습니다.

이렇게 HTTP의 비연결성과 비상태성을 보완하여 서버가 클라이언트를 식별하게 해주는 것이 쿠키와 세션입니다. 



### 쿠키 ( Cookie )

#### 쿠키란? - 쿠키는 웹 사이트에 접속할 때 **생성되는 정보를 담은** **임시 파일**

- 쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일입니다. [사용자(클라이언트)가 가지고 있는 정보]
- 사용자 인증이 유효한 시간을 명시할 수 있으며(쿠키 유효기간), 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있습니다.
- 쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조합니다.
- 클라이언트에 300개까지 쿠키저장 가능, 하나의 도메인당 20개의 값만 가질 수 있음, 하나의 쿠키값은 4KB까지 저장합니다.
- Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있습니다. (참고 https://code-machina.github.io/2019/07/29/HTTP-Header-Summary-Part-1.html#set-cookie--)
- 쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송합니다.


     ![image-20210812191253012](https://user-images.githubusercontent.com/77064907/129433233-f98d11a7-7d03-4482-a243-d11b8fb4dc86.png)


**쿠키의 동작 방식**

 쿠키도 결국 HTTP 통신에서 이루어지는 것이기 때문에 HTTP 의 응답과 요청에 따라 작동한다.

1. 클라이언트가 페이지를 요청

2. 서버에서 쿠키를 생성 및 HTTP 헤더에 쿠키를 포함 시켜 응답

   ###### 브라우저가 종료되어도 쿠키 만료 기간이 남아 있다면 브라우저(클라이언트)에서 보관하고 있음

3. 같은 요청을 할 경우 HTTP 헤더에 쿠키를 함께 보냄

4. 응답 (쿠키를 읽어 이전 상태 정보를 변경 할 필요가 있을 때 쿠키를 업데이트 하여 변경된 쿠키를 HTTP 헤더에 포함시켜 응답 - 쿠키 업데이트)

**쿠키의 구성 요소**

![image-20210812202956439](https://user-images.githubusercontent.com/77064907/129433274-d5d21078-5ab3-497e-973b-d03f603d7697.png)

- 이름 : 각각의 쿠키를 구별하는 데 사용되는 이름
- 값 : 쿠키의 이름과 관련된 값
- 유효시간 : 쿠키의 유지시간
- 도메인 : 쿠키를 전송할 도메인
- 경로 : 쿠키를 전송할 요청 경로

**쿠키의 사용 예**

- 방문 사이트에서 로그인 시, "아이디와 비밀번호를 저장하시겠습니까?"
- 쇼핑몰의 장바구니 기능
- 자동로그인, 팝업에서 "오늘 더 이상 이 창을 보지 않음" 체크

**쿠키의 단점** 

- 방문했던 웹 사이트에 대한 정보 및 개인정보가 기록되기 때문에 사생활을 침해할 소지가 있으며, 이를 해소하기 위해서 웹 브라우저 자체에 쿠키 거부 기능이 있습니다. 이러한 쿠키에 대한 거부가 웹 브라우저에 설정되어 있으면, 쿠키 본래의 목적인 웹 브라우저와의 연결을 지속시키는 기능을 수행할 수 없는 경우가 발생합니다.
- 서버가 가지고 있는 것이 아니라 사용자에게 저장되기 때문에, 임의로 고치거나 지울 수 있고, 가로채기도 쉬워 **보안이 취약합니다**. 따라서 , 쿠키에는 민감하거나 중요한 정보를 담는 것은 위험합니다.

---

### 세션 ( Session )

#### 세션이란?

- 세션은 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리합니다.
- 서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지합니다.
- 물론 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능 합니다.
- 사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 됩니다.
- 즉 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 됩니다.
- 클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 세션ID다.

**세션의 동작 방식**

1. 클라이언트가 서버에 접속 시 세션 ID를 발급받습니다.
2. 클라이언트는 세션 ID에 대해 쿠키를 사용해서 저장하고 가지고 있습니다. (세션 쿠키)
3. 클라이언트는 서버에 요청할 때, 이 쿠키의 세션 ID를 서버에 전달해서 사용합니다.
4. 서버는 세션 ID를 전달 받아서 별다른 작업없이 세션 ID로 세션에 있는 클라언트 정보를 가져옵니다.
5. 클라이언트 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답합니다.

**세션의 특징**

- 각 클라이언트에게 고유 ID를 부여
- 세션 ID로 클라이언트를 구분해서 클라이언트의 요구에 맞는 서비스를 제공
- 보안 면에서 쿠키보다 우수
- 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨

**세션의 사용 예**

- 로그인 같이 보안상 중요한 작업을 수행할 때 사용

---

#### 쿠키와 세션의 차이

- 쿠키와 세션은 비슷한 역할을 하며, 동작원리도 비슷합니다. 그 이유는 세션도 결국 쿠키를 사용하기 때문입니다.
- 가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다.
- 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다.
- 보안, 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid 만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋습니다.
- 라이프 사이클, 쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있다. 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다.
- 속도, 쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 낸다.

---

#### 세션을 사용하면 좋은데 왜 쿠키를 사용할까?

세션은 서버의 자원을 사용하기때문에 무분별하게 만들다보면 서버의 메모리가 감당 할 수 없어질 수가 있고 속도가 느려질 수 있기 때문이다.

---

#### 쿠키/세션은 캐시(웹 캐시)와 엄연히 다르다! 

- 캐시는 이미지나 css, js파일 등을 브라우저나 서버 앞 단에 저장해놓고 사용하는 것이다. (이미지 같은 브라우저를 사용하는 환경에 서버에서 받은 데이터를 저장한 파일 (쿠키와 동일)
  1. 이미지같은 재사용될 것 같거나 용량이 큰 리소스를 임시로 저장해두어서 렌더링 속도를 높이는 것이 목적!
  2. 쿠키와는 비슷하지만 목적성에 차이가 있다
- 이러한 데이터들을 매번 서버에서 전송해주는 것은 일정 수준의 부하를 요구하므로, 사용자가 웹 페이지에 접속했을 때 사용자의 컴퓨터에 캐시라는 저장 공간을 따로 마련하여 해당 웹페이지의 데이터들을 거기에 저장해두는 것이다. 그런 다음부턴 사용자가 웹 페이지를 열 때마다 서버가 아니라 캐시에 저장되어 있는 데이터를 사용하는 것입니다. 물리적으로 캐시에서 데이터를 가져오는 게 서버에서 가져오는 것보다 훨씬 빠르기 때문에 성능 향상을 꾀할 수 있다. 
- 한번 캐시에 저장되면 브라우저(사용자의 컴퓨터)를 참고하기 때문에 서버에서 변경이 되어도 사용자는 변경되지 않게 보일 수 있는데 이런 부분을 캐시를 지워주거나 서버에서 클라이언트로 응답을 보낼 때 header에 캐시 만료시간을 명시하는 방법등을 이용할 수 있다.
- 보통 쿠키와 세션의 차이를 물어볼 때 저장위치와 보안에 대해서는 잘 말하는데 사실 중요한 것은 라이프사이클에 대한 차이를 잘 알고있는 것이 중요하다.

세션은 사용자의 수 만큼 서버 메모리를 차지하기 때문에,

최근에는 이런 문제들을 보완한 토큰 기반의 인증방식을 사용하는 추세입니다.


그 중 JWT( JSON Web Token )라는 것이 있습니다.

---

## JWT( JSON Web Token )

JWT(Json Web Token)은 클레임 기반 토큰이며, 이름에서 알 수 있는 것처럼 JSON을 이용한 토큰이고 웹 표준(RFC 7519)를 구현한 것이다. 자세한 것은 [JWT 공식페이지](https://jwt.io/)에서 확인 가능하다

일반 토큰은 단순한 문자열이기 때문에 정보를 담거나 할 수 없다.
크게 보자면 아래와 같은 문제점을 가지고 있다.

- 발급된 토큰에 대해서 만료를 시킬 수단이 없다.
- 발급된 토큰을 검사하거나 처리할 때마다 DB에 접근하여 검사할 경우 부담이 생긴다.
- 사용자 로그아웃 등으로 인한 토큰을 관리할 수 있는 방법이 없다.

이와 같은 문제를 어느정도 해결할 수 있는 것이 클레임(Claim) 기반 토큰 방식이다.

클레임(Claim)이란 사용자 정보나 데이터 속성 등을 의미한다.
그래서 클레임 토큰이라 하면 토큰 안에 저런 정보를 담고 있는 토큰이라 생각하면 된다.
예를 들면 아래와 같이 정보를 담고 있는 것을 클레임 기반이라 할 수 있다.

JWT는 **헤더(header)**, **페이로드(payload)**, **서명(signature)** 세 가지로 나눠져 있다.

---

Ref

출처: https://fruitdev.tistory.com/118 [과일가게 개발자]

출처: https://noahlogs.tistory.com/38 [인생의 로그캣]

출처: https://devuna.tistory.com/23 [튜나 개발일기]

출처: https://interconnection.tistory.com/74 [라이언 서버]

출처: https://mangkyu.tistory.com/56 [MangKyu's Diary]

출처: https://elfinlas.github.io/2018/08/12/whatisjwt-01/ [MHLab Blog]

