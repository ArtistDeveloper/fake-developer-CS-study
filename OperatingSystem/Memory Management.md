# 메모리 관리 전략



## 1) 단편화(Fragmentation)

- **외부 단편화**(External fragmentation): 메모리 공간 중 사용하지 못하게 되는 일부분. 물리 메모리(RAM)에서 사이사이 남는 공간들(HOLE)을 모두 합치면 충분한 공간이 되는 부분들이 **분산되어 있을때 발생한다고 볼 수 있다. (총 공간을 계산해봤을 때 새로운 프로세스 요청을  만족할만한 충분한 메모리가 있음에도, 가능한 공간들이 연속적이지 않을 때 (즉 저장공간이 여러 hole들로 조각 나 있을 때 )  External fragmentation** 이 발생한다
- 내부 단편화: 프로세스가 사용하는 메모리 공간 에 포함된 남는 부분. 예를들어 **메모리 분할 자유 공간이 10,000B 있고 Process A 가 9,998B 사용하게되면 2B 라는 차이** 가 존재하고, 이 현상을 내부 단편화라 칭한다. (paging에서 후술)

![image](https://user-images.githubusercontent.com/77064907/125069488-c615f500-e0f1-11eb-93da-1fedca483779.png)

외부단편화 그림 / contiguous allocation(연속 할당) 방식에 의해 발생한다



![image](https://user-images.githubusercontent.com/77064907/125069702-05dcdc80-e0f2-11eb-8d27-39ae803b7492.png)

외부 단편화가 생겼을 시 해결책 COMPACTION을 설명하는 그림

### COMPACTION : 비어있는 공간을 연속적인 공간으로 만드는 작업

6번 프로세스가 들어갈 연속적인 공간을 만들기 위해 프로세스 2,3,4의 위치를 변경해주려한다.

하지만 실제로는 메모리 내에서 간단히 위치가 변경되는 것이 아닌 secondary storage(disk)에 임시로 해당 프로세스들을 저장 한 후 재배치하는 과정을 거친다. (first-fit / best-fit / worst-fit)

이러한 과정은 disk를 거쳐야하므로 성능이 떨어 질 수 밖에 없다. → paging의 등장

## 2) 페이징(paging)

페이징은 프로세스를 일정 크기인 page로 잘라서 메모리에 적재하는 방식

![image](https://user-images.githubusercontent.com/77064907/125069820-39b80200-e0f2-11eb-9dc6-3cb37d6aa63f.png)

페이징 논리주소는 page , 물리주소는 frame?

상기 이미지와 같이 페이지로 나눠 물리주소에 적재하면 하나의 프로세스를 굳이 연속적으로 배치할 필요가 없어지므로 hole이 발생하지 않는다  = 외부단편화(External fragmentation)가 발생하지 않는다.

위의 그림의 경우에는 여러개의 process가 page에 딱 맞게 나누어진 경우지만

그렇지 않은 경우가 발생 할 수도 있다.

아래의 그림을 보자

![image](https://user-images.githubusercontent.com/77064907/125069905-581dfd80-e0f2-11eb-8aef-458244cab48f.png)

내부단편화가 발생 된 Process B

고정 Page 크기로 두 프로세스를 나눴을 때 Process B의 경우 자투리 공간이 발생하였다 이를 내부단편화(internal fragmentation)이라 한다. 자투리 공간이라고해서 버리는 게 아니고 결국 프로세스의 일부기 때문에 메모리에 적재하여 사용되어야 할 부분이다.

이처럼 외부 단편화를 막게되면 내부 단편화가 발생할 수 있다. 둘 다 남는 공간이 발생하는 건 똑같다고 생각 할 수도 있겠지만 외부 단편화로 인한 메모리 낭비가 클까 ? 내부 단편화로 인한 메모리 낭비가 클까 ? 절대적인 크기로 비교 해 봤을 때 내부 단편화로인한 자투리 공간이 훨씬 적고 이로인해 Paging 기법으로 효율적인 메모리 사용이 가능하다.

2-1) **페이지 크기**

-크면 → 내부단편화 빈번히 일어남 / 매핑테이블 크기 작아짐

-작으면 → 내부단편화 드물게 일어남 / 매핑테이블 크기 커짐 / *페이지 부재 多 → 잦은 페이지 교체(swapping)로 인한 *스레싱(Thrashing) 현상 발생

ex ) 전체 페이지 크기가 55kb 페이지

-페이지,프레임 (10kb) 의 경우 내부단편화 5kb / 매핑 6회

-페이지,프레임 (4kb) 의 경우 내부단편화 1kb / 매핑 14회


*페이지 부재 : 사용하려는 페이지가 메모리에 적재가 안되어있다 = 페이지 폴트(페이지 부재) = miss

*스레싱 : 메모리가 꽉 찬 이후 새로운 프로그램을 올리기 위해 기존 프로그램을 스왑 영역에 옮기는 횟수가 증가 ⇒ **하드디스크의 입출력이 너무 많아져 잦은 페이지 부재로 CPU 성능이 급격히 저하되는 현상**


2-2) **페이지 사상 테이블 (Page Mapping Table)**

![image](https://user-images.githubusercontent.com/77064907/125070019-800d6100-e0f2-11eb-9b35-9bd2a3f5bd30.png)

페이지 테이블의 구조

![image](https://user-images.githubusercontent.com/77064907/125070065-90bdd700-e0f2-11eb-8b44-798743293e6b.png)

실제 page table의 구성 / 프레임 넘버 외에도 다양한 필드를 구성할 수 있다.

각 프로세스들의 page가 연속적으로 물리주소 프레임에 존재한는 것이 아니므로  page와 frame을 매핑시키고 프로세스를 linear하게 실행 해 줄 테이블이 필요하게된다.

페이지 테이블은 사용을 위해서 메모리에 존재해야 하지만, 그렇게 되면 메모리 접근에 있어서 중복 호출이 일어나므로(페이지 테이블에 한번, 페이지테이블을 통한 실제 메모리에 한번), 대게 *MMU 의 지원을 받아 매핑시키게 된다.

*MMU(memory management unit) : CPU코어 안에 탑재되어 가상 주소를 실제 메모리 주소로 변환해주는 장치.

![image](https://user-images.githubusercontent.com/77064907/125070197-aa5f1e80-e0f2-11eb-854d-a76a6d716729.png)

논리주소 물리주소 변환

p = 페이지번호  / f = 프레임번호 / d = 페이지offset

## 3) **세그멘테이션(Segmentation)**

- 프로세스를 서로 크기가 다른 논리적인 블록 단위인 '세그먼트(Segment)'로 분할하고 메모리에 배치하는 것을 말하며, 각 세그먼트의 크기는 일정하지 않다.
- 세그먼트를 메모리에 할당할 때는 페이지를 할당하는 것과 동일하다. 하지만, 테이블은 조금 다르다. 세그먼테이션을 위한 테이블은 **세그먼트 테이블**이라고 한다.
- 세그먼트 테이블은 세그먼트 번호와 시작 주소, 세그먼트 크기를 엔트리로 갖는다.
- 세그먼트에서 주소변환 역시, 페이징과 유사하다. 한 가지 주의할 점은 세그먼트의 크기는 일정하지 않기 때문에, 테이블에 **limit** 정보가 주어진다. 그리고 CPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해서 해당 프로세스를 강제로 종료시킨다.

![image](https://user-images.githubusercontent.com/77064907/125070289-b814a400-e0f2-11eb-9537-998b3c80890e.png)

위 그림은 세그먼트 테이블과 프로세스가 할당된 메모리의 모습.

페이징 주소변환과 동일하게 d(변위 : 변하지 않는 값)는 논리주소와 물리주소가 동일하다. 물리주소 a는 base[s]+d 로 계산된다.

- 논리 주소(2, 100) -> 물리주소 4400번지
- 논리 주소(1, 500) -> limit이 400밖에 안되므로 인터럽트로 인해 프로세스 강제 종료(범위를 벗어남)

### **세그먼테이션과 페이징**

세그먼테이션은 페이징과 유사하고 보호와 공유 측면에서는 더 나은 성능을 보여주었지만, 현재 대부분은 페이징 기법을 사용한다. 그 이유는 세그먼테이션에는 치명적인 단점이 존재하기 때문이다.

메모리 할당을 처음 시작할 때, 다중 프로그래밍에서의 문제는 크기가 서로 다른 프로세스로 인해 여러 크기의 hole이 발생한다. 이로 인해 어느 hole에 프로세스를 할당하는 것에 대한 최적화 알고리즘이 존재하지 않고, 외부 단편화로 인해 메모리 낭비가 크다고 했었다.

세그먼테이션도 똑같은 문제점이 발생한다. 왜냐하면 세그먼테이션은 논리적인 단위로 나누기 때문에 세그먼트의 **크기가 다양하다.** 이로 인해 다양한 크기의 hole이 발생하므로 같은 문제가 발생한다.

결론적으로 세그먼테이션은 보호와 공유에서 효율적이고, 페이징은 외부 단편화 문제를 해결할 수 있다. 그러므로 이 두가지를 합쳐서 사용하는 방법이 나왔다. 두 장점을 합치기 위해서는 **세그먼트를 페이징 기법으로 나누는 것이다. (Paged Segmentation)**

하지만, 이 역시 단점이 존재한다. 세그먼트와 페이지가 동시에 존재하기 때문에 주소 변환도 두번해야 한다. 즉, CPU에서 세그먼트 테이블에서 주소 변환을 하고, 그 다음 페이지 테이블에서 또 주소 변환을 해야 한다.

### ref :

https://jhnyang.tistory.com/

https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#메모리-관리-전략

https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating%20System/Paging_Segmentation.md
