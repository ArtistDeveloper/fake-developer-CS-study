# 운영체제 스터디 7/1 CPU 스케줄러

## 0. 목차 및 개요

 요즘은 장기, 중기 스케줄러는 사용하지 않고 단기 스케줄러만 남았습니다. 이 단기 스케줄러가 CPU스케줄러를 뜻하는 것이며, 앞으로 설명하는 내용은 단기 스케줄러라고 생각해도 무방합니다. 양이 많기에 인내심을 가지고 잘 읽어주면 매우 감사할 것 같습니다.

**설명 내용은 다음과 같습니다.**

1. CPU 스케줄링이란
2. CPU스케줄링의 중요한 용어
3. CPU 스케줄링의 목표 및 기준
4. CPU 스케줄링이 이루어지는 시기
5. CPU 스케줄링 전략의 분류
6. CPU 스케줄링 전략들



---

## 1. CPU 스케줄링이란

### 1.1 CPU스케줄링의 전체적인 흐름

- CPU 스케줄러는 세밀한 기준으로 다음번에 실행시킬 프로세스를 선정하는 기능을 한다.
- CPU- 케줄러가 호출되는 시점은 매우 다양한데, 현재 실행 중인 프로세스가 자발적으로 CPU를 놓거나, 또는 자신의 CPU시간 할당량을 모두 소진한 후 운영체제에 의해 강제적으로 CPU를 뺏기는 경우에 주로 호출된다.
- 즉, **CPU가 유휴 상태가 될 때마다,** 운영체제는 Ready Queue에 있는 프로세스 중에서 하나를 선택해 실행해야 한다. **선택 절차는 CPU 스케줄러**(CPU Scheduler)에 의해 수행된다.
- 그리고 CPU 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택하여, 이들 중 하나에게 CPU를 할당한다.

**요약**
 요약하자면, 자발적이든 강제적이든 CPU가 idle상태가 될 때 마다 CPU스케줄러가 Ready Queue에서 수행할 프로세스를 선택, 실행한다. 그리고 **CPU 이용률(**CPU Utilization)**을 최대화 하는 것은 다중 프로세서 운영체제 설계의 핵심이 된다.**

> * Ready Queue는 반드시 FIFO 방식의 큐가 아니어도 되고, 우선순위 큐, 트리 등으로 구현될 수 있다. 일반적으로 큐에 있는 레코드들은 프로세스의 프로세스 제어 블록(PCB)들 이다.



---

## 2. 중요한 CPU 스케줄링 용어

- **Burst Time/Execution Time(버스트 타임/실행 시간)
:** 프로세스가 실행을 완료하는 데 필요한 시간입니다. 실행 시간이라고도 한다.
- **Arrival Time(도착 시간)
:** 프로세스가 준비 상태에 들어갈 때.
- **Finish Time(완료 시간)**
**:** 프로세스가 완료되고 시스템을 종료할 때.
- **Multiprogramming(멀티 프로그래밍)
:** 동시에 메모리에 존재할 수 있는 프로그램의 수.
- **Jobs
:** 사용자 상호작용이 전혀 없는 일종의 프로그램이다.
- **User(사용자)
:** 사용자 상호작용이 있는 일종의 프로그램이다.
- **Process(프로세스)
:**  job과 user 모두에 사용되는 참조이다.
- **CPU/IO burst cycle(CPU/IO 버스트 주기)
:**  CPU와 I/O 활동을 번갈아 가며 실행하는 프로세스 실행을 특성화한다. CPU 시간은 일반적으로 I/O 시간보다 짧다.



---

## 3. CPU 스케줄링의 목표 및 기준

### 3.1 CPU스케줄링의 목표

 운영체제에서 구현되는 CPU 스케줄러의 기본 목표 중 하나는 사용자 프로세스들의 기다리는 시간을 줄여, 가능한 한 신속하게 처리될 수 있도록 하는 것이다.

 일반적으로 어떤 CPU 스케줄링 방식의 효율성을 평가할 때에는 다양한 평가 기준이 동원된다. 어떤 스케줄러가 **어떤 한 측면에서 우수한 성능을 보였다고 해도 다른 어떤 면에서는 뒤쳐질 수 있기 때문이다.**

### 3.2 CPU스케줄링의 기준

 **스케줄러에 대한 평가는** 우선 크게 **사용자 관점**과 **시스템 관점 두 가지 측면**으로 분류할 수 있다. 그리고 CPU스케줄링 알고리즘은 다음을 최대화하고 최소화하려고 한다.

**사용자 관점에서의 CPU 스케줄링 성능 관련 평가척도 (최소화 해야함):**

- 응답 시간(Response Time): 사용자 데이터 입력 후, 출력이 이루어질 때까지의 소요 시간.
- 반환 시간(Turnaround Time): 프로그램 제출(혹은 시작) 후, 끝날 때까지 소요되는 총 시간.
- 대기 시간(Waiting Time): 프로세스들이 준비 상태로 대기열에서 기다린 시간의 총합 .

**시스템 관점에서의 CPU 스케줄링 성능 관련 평가척도 (최대화 해야함) :**

- CPU 이용률(CPU Utilization): 총 경과 시간 대비 CPU가 순수하게 사용자 프로세스를 수행한 시간의 비.
- 처리량(Throughput): 단위 시간당 처리된 프로세스의 개수.

**아래 사진을 참고하면 응답, 대기, 반환 시간의 개념을 조금 더 이해하기 수월할 것이다.**

![Untitled](https://user-images.githubusercontent.com/40491724/125200579-ba1f6400-e2a6-11eb-8f76-1de9ee42339d.png)

**대기시간** : 프로세스가 실행까지 걸리는 시간

**응답시간** : 요청한 프로세스가 실행되어 응답을 받을때까지 걸리는 시간

**실행시간(Brust time, run time)** : 프로세스 실행부터 종료까지 걸린시간

**반환시간** :  대기시간 + 실행시간



---

## 4**. CPU 스케줄링이 이루어지는 시기**

### 4.1 CPU/IO 버스트 주기 (CPU/IO Burst Cycle)

> CPU 버스트(CPU Burst) : 프로세스가 대기 상태에 있다가 **CPU를 할당받아 실행하는 주기**
I/O 버스트(I/O Burst) : 입출력 작업의 주기

### 4.2 **프로세스 실행의 사이클**

- 프로세스의 실행: CPU실행과 I/O 대기의 사이클로 구성된다.
- 프로세스의 실행은 CPU Burst로 시작된다. 뒤이어 I/O Burst가 발생하고, 그 뒤를 이어 또 다른 CPU Burst가 발생하며, 이어 또 다른 I/O Burst 등등으로 진행된다. 결국 아래의 그림처럼 마지막 CPU Burst는 실행을 종료하기 위한 시스템 요청과 함께 끝난다.

![Untitled 1](https://user-images.githubusercontent.com/40491724/125200575-b7247380-e2a6-11eb-8711-bcdbe14869ab.png)

그래서 프로세스가 CPU burst와 I/O wait을 하는 cycle을 반복하는데 이것을 반영한 스케줄링이 중요하다.

### 4.3 **CPU스케줄링의 결정은 다음의 네 가지 상황에서 발생할 수 있다.**

**1. 실행 상태에서 대기 상태로 전환될 때**

- I/O 요청 또는 자식 프로세스들 중 하나의 대기 상태의 호출이 발생할 때.
- accept(), connect(), send(), recv(), open(), close(), fgets(), printf() 등은 모두 운영체제의 입/출력 시스템 콜이어서, 입/출력이 완료될 때까지 그 프로세스는 CPU 할당을 받지 못하는 I/O 버스트이다.
- 그 외 부분은 CPU 버스트다. **I/O 버스트가 시작되면 운영체제는 CPU를 다른 프로세스에게 할당해주어야 하는데,** 이 경우가 가장 **대표적인 CPU 스케줄링 시기다.**

**2. 실행 상태에서 준비 상태로 전환될 때**

- 인터럽트가 발생할 경우에 실행 상태에서 준비 상태로 전환된다.

  **2.1** **주어진 CPU 실행 시간을 초과했을 때**

- 대부분의 사용자 프로그램은 CPU 버스트와 I/O 버스터가 번갈아 섞여 있어서, 다수의 프로세스 사이에서 CPU가 자연스럽게 고루 할당된다.
- 그러나 어떤 프로그램은 입/출력이 극히 적고 계산식으로만 이루어져 있어서 CPU의 고른 분배가 어려워질 수 있다. 이를 해결하기 위해 어느 한 프로세스가 연속해서 사용할 수 있는 최대 시간을 설정하고, 시간이 초과한 경우 CPU를 다른 프로세스에게 할당할 수 있다. ⇒ Round Robin
- 이때 지정된 최대 시간을 타임 퀸텀(Time Quantum) 또는 타임 슬라이스(Time Slice)라 부른다.

**3. 대기 상태에서 준비 상태로 전환될 때**

- I/O완료

**3.1** **높은 우선순위의 프로세스가 나타났을 때**

- 입/출력 상태에 있던 프로세스는(대기 상태였던 프로세스) 입/출력이 완료되면 준비 상태가 되어 CPU 할당 대상에 새롭게 추가된다.
- 즉, 입/출력 완료 인터럽트가 발생하면 CPU는 실행 중이던 프로세스에서 잠시 떠나 운영체제의 인터럽트 핸들러로 이동하여 준비 상태의 새로운 프로세스가 나타났음을 인식하고, 만약 이 새로운 프로세스의 우선순위가 이전에 떠나왔던 프로세스보다 높다면 CPU 스케줄링 방법에 따라 CPU 할당을 즉시 교체할 수 있다.

**4. 프로세스가 종료될 때**

- 사용자가 작성한 프로그램을 컴파일하고 링크하면 목적 코드(실행 파일)에는 프로그램의 끝부분에 운영체제에게 종료를 요구하는 코드가 자동으로 링크된다.

> **1, 4번은 비선점 스케줄링이 발생한다.**
 상황1, 4의 경우에는 스케줄링 측면에서 선택의 여지가 없다. 실행을 위해 새 프로세스(Ready Queue에 프로세스가 존재하는 경우)를 선택해야 한다.

**2, 3번의 경우 선점 스케줄링이 발생한다.**
 상황2, 3번의 경우 현재 프로세스를 계속 실행하거나 다른 프로세스를 선택할 수 있다.



---

## 5**. CPU 스케줄링 전략의 분류**

![Untitled 2](https://user-images.githubusercontent.com/40491724/125200601-cacfda00-e2a6-11eb-8254-812899cd4a22.png)

- 프로세스 스스로의 요구에 의해 이루어지는 자율적 CPU 반납: 입/출력, 종료
- 외부 상황에 따라 CPU를 강제로 회수당하는 타율적 CPU 반납: 높은 우선순위 출현, 타임 퀀텀 초과

CPU 반납 방식의 자율성 및 타율성 여부에 따라 **CPU 스케줄링 전략은** **비선점형**과 **선점형**으로 분류된다.

### **비선점 스케줄링(Non-preemptive)**

⇒ 자율적 CPU반납만 허용합니다.

- 비선점 스케줄링(nonpreemptive)하에서는, 일단 CPU가 한 프로세스에 할당되면 프로세스가 종료하든지, 또는 대기(blocked) 상태로 전환해 CPU를 방출할 때까지 점유한다. 
(I/O 발생 및 프로스세가 종료할 때)
- 입/출력이 적은 계산 위주(CPU Bounds) 프로세스가 다수 적재되어 있다면 다른 프로세스들의 응답 시간은 매우 저조할 것이다. 반대로 프로세스들이 입/출력 위주(I/O Bounds)라면 CPU를 어느 정도 규칙적으로 번갈아 할당받을 수 있으므로 응답 시간이 크게 나쁘지 않을 것이다.
- 

### **선점 스케줄링(Preemptive)**

⇒ 타율적 CPU반납도 허용합니다.

- 자율적 CPU 반납은 물론 타율적 CPU 반납까지 이루어지는 운영체제 환경이다.
- 선형 운영체제 환경에서는 어떤 프로세스도 일정 시간(타임 퀀텀) 이상 동안 연속해서 CPU를 점유할 수 없으므로 계산 위주 프로세스가 많이 적재되어 있다 하더라도, 모든 프로세스의 반응 시간 성능을 평균 이상으로 유지할 수 있다.
- 선점 스케줄링(Preemptive)은 시분할 시스템에서 타임 슬라이스가 소진되었거나, 인터럽트나 시스템 호출 종료시에 더 높은 우선 순위 프로세스가 발생 되었음을 알았을 때, 현 실행 프로세스로부터 강제로 CPU를 회수하는 것을 말한다. (인터럽트 발생, I/O 종료)



---

## 6. CPU 스케줄링 전략들

### FCFS: First-Come First-Served스케줄링 (선입 선처리 스케줄링) //비선점

![Untitled 3](https://user-images.githubusercontent.com/40491724/125200605-cd323400-e2a6-11eb-856d-2f5ca445ffc2.png)

- 비선점형 방식
- 선입선출 방식으로, Ready Queue에 도착한 순서대로 CPU를 할당한다.
- 모든 프로세스의 우선순위가 동일하고, 프로세스의 CPU 처리 시간을 따로 고려하지 않기 때문에 매우 단순하고 공평한 방법이다.

> **Convoy Effect**

CPU 처리 시간이 긴 프로세스가 앞에 올 경우 뒤의 프로세스가 한없기 기다려야 하기 때문에 비효율적이게 된다. 이를 **호위 효과(Convoy Effect)**라고 한다. 

근본적으로 FCFS가 비선점형 CPU스케줄링이기 때문에 일어난다.

그림에서 보이듯이 CPU 버스트 타임이 2ms인 P4는 잠깐만 CPU를 얻으면 빠르게 처리하고 나갈 수 있지만 4번 째로 도착했기 때문에 30ms나 대기해야 한다.

### SJF: Shortest Job First 스케줄링 (최단 작업 우선) //비선점

![Untitled 4](https://user-images.githubusercontent.com/40491724/125200608-cefbf780-e2a6-11eb-8571-da9cd1acd547.png)

- CPU 버스트가 가장 짧은 프로세스를 CPU에 먼저 할당하는 전략이다.
- 단, 비선점형 방식이기 때문에 CPU를 사용중인 프로세스보다 처리 시간이 짧더라도 빼앗지는 못한다.
- 평균 대기 시간과 평균 응답 시간이 FCFS에 비해 개선되었으나, SJF는 비선점형이므로 계산 위주의 긴 프로세스에 CPU가 할당된 상태에서 다수의 입/출력 위주 짧은 프로세스들이 도착한다면 마찬가지로 호위 효과가 일어날 수 있다.
- 일단 가장 중요한 공평성에 어긋난다. 처리 시간이 긴 프로세스의 경우 처리 시간이 짧은 프로세스가 계속해서 들어온다면 대기 큐에서 영영 CPU를 할당받지 못할 수 있다. 이를 starvation 현상(기아 현상)이라고 한다.
- ⇒ 짧은 프로세스들이 지속적으로 도착한다면, 상대적으로 긴 프로세스는 계속해서 지연되는 단점이 있다. 이처럼 계속해서 지연되는 상황을 보통 기아 현상이라고 부른다.
- 그리고 중간에 입출력 버스트가 빈번하게 요구되는 프로세스의 경우 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다.

### **HRN(Highest Response Ratio Next) (비선점)**

SJF 스케줄링에 **Aging** 기법을 합친 비선점형 알고리즘이다.

Aging이란 나이를 먹는다는 의미 그대로 starvation을 해결하기 위해 대기 시간이 길어지면 우선순위를 높여주는 방법이다.

SJF와 마찬가지로 실행 시간이 적은 프로세스의 우선 순위가 높지만 대기 시간이 너무 길어지면 실행 시간이 길더라도 CPU를 할당받을 수 있다. 하지만 여전히 공평성이 말끔히 해결되지는 않는다.

### **SRTF (Shortest Remaning Time First) 최단 잔여 시간 우선 (선점)**

SJF의 **선점형 방식**이다. 먼저 온 프로세스가 CPU를 할당받고 있더라도 남은 처리 시간이 뒤에 온 프로세스의 처리 시간보다 길면 CPU를 빼앗긴다.

![Untitled 5](https://user-images.githubusercontent.com/40491724/125200612-d0c5bb00-e2a6-11eb-9bba-b28b3832f83b.png)

- 어떤 알고리즘보다 **평균 대기 시간이 가장 짧은 알고리즘**이다.
- 하지만 이 방식은 기본적으로 선점형 방식이기 때문에 잦은 문맥교환이 일어나고 그에 따른 오버헤드가 커진다. 그리고 **starvation 현상 (기아 현상)이 더 심각하게 발생**할 수 있다.
- 또한 CPU의 예상 시간을 예측하기가 너무 힘들기 때문에 실제로 사용되기가 매우 어렵다. (exponential averaging을 통해 예측을 할 수는 있다)

### Priority Scheduling

- 프로세스의 중요도에 따라 매긴 우선순위를 반영한 알고리즘으로 위에서 알아본 SJF, HRN, SRTF도 우선순위 스케줄링 알고리즘의 일종이다.
- 위의 알고리즘들의 문제점과 마찬가지로 starvation 문제와 공평성 문제가 있다.

### RR(Round Robin) //선점

![Untitled 6](https://user-images.githubusercontent.com/40491724/125200614-d1f6e800-e2a6-11eb-93fd-8f0f695133ab.png)

- **실행의 최소 단위시간을 타임퀀텀(Time Quantum) 또는 타임슬라이스(Time Slice)라 하는데**, 이를 기준으로 하여서 정해진 시간마다 CPU를 할당하고 그 시간이 지나면 다음 프로세스를 타임퀀텀만큼 CPU를 할당한다.
- 프로세스에게 각각 동일한 CPU 할당 시간(타임 슬라이스, quantum)을 부여해서 이 시간 동안만 CPU를 이용하게 한다. 만약 할당 시간동안 처리를 다 하지 못하면 CPU를 빼앗고 다음 프로세스에게 넘긴다. 빼앗긴 프로세스는 준비 큐의 맨 뒤로 간다. 따라서 선점형 방식이다.
- 따로 CPU 처리 시간을 계산하지 않아도 돼서 선점형 방식의 가장 단순하고 대표적인 방법이다. 우선 순위도 없기 때문에 매우 공평하다.
- 자연히 Convoy Effect도 줄어든다.

위의 경우 time quantum = 5인 경우다. 타임 퀀텀(타임 슬라이스)동안 처리를 다 하지 못한 P1은 CPU를 빼앗기고 대기 큐의 맨 뒤로 간 다음 P2에게 넘겨준다. P2는 3ms만에 처리를 완료하고 바로 P3에게 CPU를 넘겨준다.

### **타임 슬라이스의 크기 결정**

- 라운드 로빈 방식에서 가장 중요한 부분은 타임 슬라이스의 크기 결정이다.
- **타임 슬라이스가 큰 경우** 처리 시간이 긴 프로세스에 의해 CPU의 효율성이 떨어질 수 있다. 비디오 플레이어와 워드 프로세서를 동시에 실행했을 때 타임 슬라이스가 크다면 비디오가 약간 씩 끊겨서 재생될 것이다. 그리고 만약 타임 슬라이스가 무한대로 설정되면 FCFS 스케줄링과 다를 바 없어진다.
- **타임 슬라이스가 작은 경우** 여러 프로그램이 동시에 실행되는 효과를 볼 수 있다. 하지만 너무 작으면 잦은 문맥 교환이 일어나 오버헤드가 상당히 커진다.

**때문에 적당한 타임 슬라이스를 설정하는 것이 중요하다.** 보통 10-100 ms로 설정한다



---

### Multilevel Queue (다단계 큐)

**전면 프로세스** : GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓여 현재 입출력이 사용되고, 사용자와 상호작용이 가능해 상호작용 프로세스라고도 불림 (워드 프로세스)

**후면 프로세스** : 사용자의 입력 없이 작동하여 일괄 작업 프로세스라고 불림 (압축 프로세스)

전면 프로세스는 사용자의 요구에 즉각 즉각 반응해야 하지만 후면 프로세스는 그럴 필요가 없다. 따라서 전면 프로세스를 먼저 처리해 줘야 한다.

RR의 단점은 최적의 타임 퀀텀 찾기와 설정된 타임 퀀텀으로 인해 프로세스 특성을 고려할 수 없다는 것이다. 이를 해결하기 위한 방안으로 프로세스 특성별로 준비 큐를 여러 개 두어 우선순위를 부여하고, 높은 우선순위 큐들이 모두 비었을 때만 다음 단계의 낮은 우선순위의 큐 프로세스들에게 CPU를 할당하는 MQ 스케줄링 전략을 도입했다.

- 시스템 프로세스 준비 큐 (우선순위 가장 높음)
- 대화형(입/출력 위주) 프로세스 준비 큐
- 계산 위주 프로세스 준비 큐
- 후면처리 프로세스 준비 큐 (우선순위 가장 낮음)

각 Ready Queue에는 해당 프로세스의 특성을 반영하는 타임 퀀텀을 설정한다. 예를 들어 대화형 프로세스들은 CPU 버스트 시간이 짧으므로 긴 타임 퀀텀이 필요 없고, 계산 위주 프로세스들은 타임 퀀텀이 길면 콘텍스트 스위칭 빈도가 줄어 시스템 부담을 줄일 수 있다. 또한, 같은 Ready Queue 프로세스들 간에는 FCFS, SJF, RR 등 다른 스케줄링 전략등을 적용할 수 있다.

어쨌든 Multilevel Queue는 **프로세스들을 우선 순위에 따라 여러 레벨의 그룹으로 분류하는 것.** 

- 다단계 큐 스케줄링은 우선순위에 따라 준비 큐를 여러 개 사용하는 방식이다.
- 당연히 우선순위가 높은 큐에 먼저 CPU가 할당되어 큐에 속한 모든 프로세스가 처리되야 다음 우선순위 큐가 실행될 수 있다. 그리고 한 번 우선순위가 매겨저 준비 큐에 들어가면 이 우선순위는 바뀌지 않는다.
- 운영체제는 프로세스들을 분류할 때 보통 사용자와 상호작용하는 앞단의 프로세스들은 중요하다고 판단하고 백그라운드에서 돌아가는 프로세스(일괄처리형 batch processes)들은 상대적으로 덜 중요하다고 판단하여 분류하는 것이 일반적인 경우이다.

![Untitled 7](https://user-images.githubusercontent.com/40491724/125200617-d3c0ab80-e2a6-11eb-8c59-b3d63eacadb2.png)

각 큐는 독립적인 스케줄링 알고리즘을 가질 수 있는데, 보통 전면 프로세스들이 속해있는 큐는 우선순위고 높고 라운드 로빈 스케줄링을 사용해 타임 슬라이스를 작게한다.

후면 프로세스에는 사용자와의 상호작용이 없으므로 가장 간단한 FCFS 방식(다운로드, 압축풀기)으로 처리한다. 보통 총 CPU 시간이 전면 프로세스의 처리에 80%, 후면 프로세스 처리에 20%가 할당된다.

이 다단계 큐 알고리즘 역시 문제는 starvation 현상과 공평성 문제다.

No process in the batch queue could run unless the queues for system processes, interactive processes, and interactive editing processes were all empty.

이 문장은 프로세스는 절대적인 우선 값을 지니고 있어서 나보다 중요한 프로세스들이 완료되지 않으면 하위 프로세스들은 실행되지 못한다는 내용이다.

### **Multilevel Feedback Queue**

![Untitled 8](https://user-images.githubusercontent.com/40491724/125200619-d4f1d880-e2a6-11eb-954b-7cec1e567d74.png)

- 다단계 큐의 공평성 문제를 완화하기 위해 신분 하락이 가능한 알고리즘이다. 이 알고리즘에서는 우선순위가 변동되기 때문에 큐 사이의 이동이 가 하다.
- 한 번 CPU를 할당받은 프로세스는 우선순위가 조금 낮아진다. 따라서 더 낮은 큐로 이동하게 된다. (우선순위가 높아져 상위 큐로 이동할 수도 있다)
- 그리고 더 보완하기 위해 우선순위가 높은 큐보다 우선순위가 낮은 큐에 타임 슬라이스 크기를 크게 준다. 어렵게 얻은 CPU를 좀 더 오랫동안 사용하게 해주기 위함이다.

⇒ 기아 상태 생김. 이럴 때는 aging방식을 도입해서 해결할 수 있다.

---

**출처**

[http://boron.physics.metu.edu.tr/ozdogan/OperatingSystems/week5/node19.html](http://boron.physics.metu.edu.tr/ozdogan/OperatingSystems/week5/node19.html)

[https://boycoding.tistory.com/258](https://boycoding.tistory.com/258)

[https://www.geeksforgeeks.org/cpu-scheduling-criteria/](https://www.geeksforgeeks.org/cpu-scheduling-criteria/)

[https://www.guru99.com/cpu-scheduling-algorithms.html](https://www.guru99.com/cpu-scheduling-algorithms.html)

[https://haerong22.tistory.com/106](https://haerong22.tistory.com/106)

[https://ocw.snu.ac.kr/sites/default/files/NOTE/2569.pdf](https://ocw.snu.ac.kr/sites/default/files/NOTE/2569.pdf)

[https://www.u-aizu.ac.jp/~yliu/teaching/os/lec10r.html](https://www.u-aizu.ac.jp/~yliu/teaching/os/lec10r.html)

[http://web.cs.ucla.edu/classes/fall08/cs111/scribe/8/index.html](http://web.cs.ucla.edu/classes/fall08/cs111/scribe/8/index.html)

https://bnzn2426.tistory.com/65