# Context Switching

운영 체제를 공부하다보면, Context Switching이라는 단어가 많이 나오게 됩니다. 실제로 운영체제가 작동하는 중에는 정말 많은 Context Switching이 발생하기 때문에 이 Context Switching에 대해 제대로 알아보겠습니다.





## 컴퓨터 구조

먼저 Context Switching에 대해 더 쉽게 이해하기 위해 간단하게 컴퓨터의 구조부터 알아보겠습니다.

컴퓨터 구조란 하드웨어를 구성하는 각 장치의 특성과 동작 원리를 다루는 학문입니다. 컴퓨터는 크게 하드 웨어와 소프트 웨어로 나누어집니다.



### 하드 웨어

하드 웨어는 컴퓨터를 구성하는 기계적 장치를 말합니다. 하드 웨어의 기본적인 구성은 아래와 같습니다.

- 중앙처리장치 : CPU
- 기억장치 : RAM, HDD
- 입출력장치 : 마우스, 키보드, 프린터, 모니터

<img src="https://user-images.githubusercontent.com/79291114/124373010-d9782900-dcc9-11eb-873c-44f614355566.png" alt="computer" style="zoom:150%;" />

하드웨어의 각 장치는 시스템 버스로 연결되어 있습니다.

> 시스템 버스 : 데이터와 명령 제어 신호를 각 장치로 실어 나르는 역할을 합니다. 용도에 따라 데이터 버스, 주소 버스, 제어 버스로 나누어집니다.



#### 중앙처리장치

인간으로 따지면 두뇌에 해당하는 부분이라고 많이 말합니다.

주기억장치는 프로그램 명령어와 데이터를 읽어와 처리하고 명령어의 수행 순서를 제어하는 반면에, 중앙처리장치는 비교와 연산을 담당하는 `산술논리연산장치(ALU)`와 명령어의 해석과 실행을 담당하는 `제어장치`, 속도가 빠른 데이터 기억장소인 `레지스터`로 구성되어있습니다.

개인용 컴퓨터와 같은 소형 컴퓨터에서는 CPU를 마이크로프로세서라고도 부릅니다.

**참고 링크**

[중앙처리장치(CPU) 작동 원리](https://gyoogle.dev/blog/computer-science/computer-architecture/%EC%A4%91%EC%95%99%EC%B2%98%EB%A6%AC%EC%9E%A5%EC%B9%98%20%EC%9E%91%EB%8F%99%20%EC%9B%90%EB%A6%AC.html)



#### 기억장치

프로그램, 데이터, 연산의 중간 결과를 저장하는 장치입니다.

주기억장치와 보조기억장치로 나누어지며, RAM과 ROM은 주기억장치에 해당합니다. 실행중인 프로그램의 필요한 데이터를 일시적으로 저장합니다.

보조기억장치는 하드디스크 등을 말하며, 주기억장치에 비해 속도는 느리지만 많은 자료를 영구적으로 보관할 수 있습니다.



#### 입출력장치

입력과 출력 장치로 나누어집니다.

입력장치는 컴퓨터 내부로 자료를 입력하는 장치(키보드, 마우스 등)를 말하고,

출력장치는 컴퓨터에서 외부로 표현하는 장치(프린터, 모니터, 스피커 등)를 말합니다.



### 소프트 웨어

소프트웨어는 하드웨어의 동작을 지시하고 제어하는 명령어의 집합입니다. 소프트 웨어의 기본적인 구성은 아래와 같습니다.

- 시스템 소프트웨어 : 운영체제, 컴파일러
- 응용 소프트웨어 : 워드프로세서, 스프레드시트(프로그램) 등등





## Context Switching

`Context Switching`은 멀티 프로세스 환경에서 CPU가 하나의 프로세스를 실행하고 있는 도중에, `인터럽트` 요청에 의해 다음 우선순위의 프로세스가 실행되어야할 때 기존까지의 작업, 즉 레지스터 값(`Context`)을 `PCB(Process Control Block)`에 저장한 뒤 다음 프로세스를 CPU가 수행할 수 있도록 **프로세스의 상태나 값을 교체하는 작업**을 말합니다.

> 즉, 프로세스가 Ready→Running, Running→Ready, Running→Waiting처럼 상태 변경 시 발생합니다.



### Context

윈도우나 리눅스 같은 멀티 프로세스 운영체제에서는 여러 개의 프로세스들이 CPU 스케쥴링을 통해 CPU 실행 시간을 나누는 방식으로 동시에 실행되는 듯한 효과를 얻습니다. 

그런데 실행중인 프로세스의 변경은 시스템에 많은 부하를 일으킵니다. 그 이유는 CPU 내에 존재하는 레지스터들이 현재 실행중에 있는 프로세스 관련 데이터로 채워지는데, 실행중인 프로세스가 변경되면 CPU 내에 존재하는 레지스터들의 값이 변경되기 때문입니다.

이 경우 다른 프로세스가 실행되고 나서 이전의 프로세스를 재 실행시키기 위하여 레지스터 값들을 어딘가에 저장해야 하며, 다른 프로세스의 작업이 완료되면 이전 프로세스의 데이터(레지스터 값)를 복원시켜야 합니다.

즉 운영체제에서 CPU가 해당 **프로세스를 실행하기 위한 프로세스의 데이터(CPU의 레지스터 값)을 컨텍스트(Context)** 라고 하며, **실행할 프로세스가 바뀔 때 마다 레지스터의 값들도 바뀌게 되는데, 이를 컨텍스트 스위칭(Context Switch)** 이라고 합니다.



### PCB(Process Control Block)

위와 같은 **Context는 프로세스의 PCB(Process Control Block)에 저장**하게 됩니다. 그래서 Context Switching이 이루어질 때, CPU가 PCB의 정보를 읽어(적재) 이전에 프로세스가 수행 중이었던 작업을 계속 수행하는 것입니다. 이 때, CPU는 각 프로세스들을 구별할 수 있어야 관리가 가능합니다. 아래와 같은 프로세스의 특징을 `Process Metadata`라고 하고 이 **Metadata는 프로세스가 생성되면 PCB에 저장**됩니다.

> Metadata : 데이터를 위한 데이터입니다. 즉, **어떤 데이터의 구조화된 정보를 분석, 분류하고 부가적 정보를 추가하기 위해 그 데이터 뒤에 함께 따라가는 정보**를 말합니다.

<img src="https://user-images.githubusercontent.com/79291114/124494648-10495e80-ddf2-11eb-8873-b2ea104d0b9a.png" alt="PCB" style="zoom: 50%;" />



#### Process Metadata

- Process ID :  프로세스 고유 식별 번호, `PID(Process Identification Number)` 라고도 함 
- Process State : 프로세스의 현재 상태( `new`, `ready`, `running`, `waiting`, `terminated` 등)를 기억
- Program Counter : 프로세스가 다음에 실행할 명령어의 주소
- Process Priority : 프로세스 우선순위 등과 같은 스케줄링 관련 정보를 기억
- CPU Registers : 프로세스의 레지스터 상태를 저장하는 공간 등. CPU 내 범용 레지스터(AX, BX, CX, DX), 데이터 레지스터(SP, BP, SI, DI), 세그먼트 레지스터(CS, DS, ES, SS) 등이 갖고 있는 값을 기억
- Owner : CPU 사용시간의 정보(Quantum), 각종 스케줄러에 필요한 정보, 계정 정보등을 기억
- 메모리 관리 정보 : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
- 입출력 상태 정보 : 프로세스에 할당된 입출력 장치들과 열린 파일 목록



#### PCB의 관리 방식

PCB는 Linked List 방식으로 관리됩니다. PCB List Head에 PCB들이 생성될 때마다 붙게 되고 주소값으로 연결 되어 있기 때문에 **삽입 삭제가 용이**합니다.

**즉, 프로세스가 생성되면서 해당 PCB가 생성되고 프로세스 완료 시 제거될 때, 더 효율적인 것입니다.**



### 인터럽트

인터럽트란, CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치에 문제가 발생하거나 예외상황이 발생하여 처리가 필요할 경우, **현재 실행중인 작업을 중단하고 발생된 상황을 처리한 후 다시 실행중인 작업으로 복귀하는 것**을 말합니다.

인터럽트는 `외부 인터럽트`와 `내부 인터럽트`로 구분하는데, **외부 인터럽트를 하드웨어 인터럽트, 내부 인터럽트를 소프트웨어 인터럽트라고 합니다.**



#### 하드웨어 인터럽트 **(Hardware Interrupt)**

- 그냥 인터럽트라 하면, 일반적으로 `하드웨어 인터럽트`를 의미합니다.
- **외부 인터럽트는 프로그램 외부에서 일어나는 인터럽트**입니다.
- `기계 검사 인터럽트`, `입출력 인터럽트`, `전원 이상 인터럽트` 등이 있습니다.



#### 소프트웨어 인터럽트 (Software Interrupt, Trap)

- 내부 인터럽트는 `소프트웨어 인터럽트`와 같은 개념이라고 보면 됩니다.
- `트랩(Trap)`이라고도 하며, **프로그램 내부에서 일어나는 인터럽트**입니다. `예외`와 `시스템 콜`이 있습니다.
- `예외 (Exception)` : 메모리 참조 오류, 0으로 나누기, Overflow, Underflow 등의 경우에서 발생하는 인터럽트
- `시스템 콜 (System Call)` : 사용자가 의도적으로 일으킨 인터럽트



#### 인터럽트와 트랩의 차이점

- `인터럽트` : 하드웨어적 흐름의 변화 / 프로그램 외부(I/O 장치, 디스크 등)에서 발생하며, 발생 시점이 일정하지 않기 때문에 비동기적입니다.
- `트랩` : 소프트웨어적 흐름의 변화 / 소프트웨어 인터럽트라고도 하며, 프로그램 내부에서 일어나는 에러입니다. 발생 시점이 프로그램의 일정한 지점이기 때문에 동기적입니다. 즉, 고정된 영역에서 일어납니다.



#### 인터럽트 과정

`Process A` 실행 중 디스크에서 어떤 데이터를 읽어오라는 명령을 받았다고 가정해봅니다.

1. `Process A`는 `system call`을 통해 인터럽트를 발생시킵니다.
2. CPU는 현재 진행 중인 기계어 코드를 완료합니다.
3. 현재까지 수행중이었던 상태를 해당 Process의 `PCB(Process Control Block)`에 저장합니다. (수행중이던 Memory 주소, 레지스터 값, 하드웨어 상태 등…)
4. `PC(Program Counter)`에 다음에 실행할 명령의 주소를 저장합니다.
5. `인터럽트 벡터(인터럽트 발생시 처리해야 할 인터럽트 핸들러의 주소를 인터럽트 별로 보관하고 있는 테이블)`를 읽고 `ISR` 주소값을 얻어 `ISR(Interrupt Service Routine)(인터럽트를 처리하기 위해 커널이 실행하는 함수)`로 점프하여 루틴을 실행합니다.
6. 해당 코드를 실행합니다.
7. 해당 일을 다 처리하면, 대피시킨 레지스터를 복원합니다.
8. `ISR`의 끝에 `IRET(Interrupt Return)` 명령어에 의해 인터럽트가 해제 됩니다.
9. `IRET` 명령어가 실행되면, 대피시킨 PC 값을 복원하여 이전 실행 위치로 복원합니다.



### Context Switching의 필요성

결국 **CPU의 레지스터 정보가 변경되는 것을 Context Switching**이라고 하는데, 왜 Context Switching이 필요한 것일까요??

만약 컴퓨터가 매번 하나의 Task만 처리할 수 있다고 가정하면 아래와 같은 상황이 발생합니다.

- 다음 Task를 처리하기 위해서 현재 Task가 끝날 때까지 기다려야 합니다.
- 반응속도가 매우 느리고 사용하기 불편합니다.

때문에 CPU가 Task를 바꿔가며 실행하여 **다양한 사람들이 동시에 사용하는 것처럼 하기 위해서 Context Switching이 필요**하게 되었고 아래와 같은 이점이 있습니다.

- 컴퓨터 멀티태스킹을 통해 빠른 반응속도로 응답 가능합니다.
- 빠르게 Task를 바꾸면서 실행하기에 사람은 실시간처리가 되는 것처럼 보입니다.



### Context Switching과 시간 할당량

프로세스들의 시간 할당량은 시스템 성능의 중요한 역할을 합니다. 시간 할당량이 적을수록 사용자 입장에서는 여러 개의 프로세스가 거의 동시에 수행되는 느낌을 갖지만 인터럽트의 수와 Context Switching의 수가 증가합니다. 또, Context Switching의 수가 증가하면 Overhead도 증가합니다. 정리하자면 다음과 같습니다.

- 시간 할당량이 적어지면 : Context Switching 수, 인터럽트 횟수, Overhead가증가하지만 여러 개의 프로세스가 동시에 수행되는 느낌을 갖습니다.
- 시간 할당량이 커지면 : Context Switching 수, 인터럽트 횟수, Overhead가 감소하지만 여러 개의 프로세스가 동시에 수행되는 느낌을 갖지 못 합니다.

> Overhead : 프로세스의 실행을 위한 부가적인 활동 즉, 간접 부담 비용을 말합니다. 



**프로세스를 실행하다가 I/O event가 발생하여 BLOCK 상태로 전환시켰을 때, CPU가 대기하는 것보다 다른 프로세스를 실행하는 것이 효율적**이므로, CPU에 계속 프로세스를 실행시키도록 하기 위해서 다른 프로세스를 실행시키고 Context Switching을 할 때 Overhead가 발생하는 것입니다.



### Context Switching Cost

Context Switching이 발생하게 되면 다음과 같은 Cost가 소요됩니다.

- Cache 초기화
- Memory Mapping 초기화
- 메모리의 접근을 위해서 Kernel은 항상 실행되어야 합니다.

따라서 잦은 Context Switching은 성능 저하를 가져옵니다.



#### Process vs Thread

Context Switching 비용은 Process가 Thread보다 많이 듭니다. 그 이유는 Thread는 Stack 영역을 제외한 모든 메모리를 공유하기에 Context Switching 발생 시 Stack 영역만 변경하면 되기 때문입니다.



---

참고 : [https://gyoogle.dev/blog/](https://gyoogle.dev/blog/)

[https://dlaxodud2388.tistory.com/21](https://dlaxodud2388.tistory.com/21)

[https://jeong-pro.tistory.com/93](https://jeong-pro.tistory.com/93)

[https://m.blog.naver.com/adamdoha/222019884898](https://m.blog.naver.com/adamdoha/222019884898)

